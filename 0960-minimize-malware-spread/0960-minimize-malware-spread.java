class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        DSU dsu = new DSU();
        int n = graph.length;
        Arrays.sort(initial);
        HashSet<Integer> initials = new HashSet<>();
        for (int i : initial) {
            initials.add(i);
        }
        boolean[] isCandidate = new boolean[n];
        boolean[] visited = new boolean[n];
        Arrays.fill(isCandidate, true);
        for (int init : initial) {
            Queue<Integer> q = new ArrayDeque<>();
            for (int i = 0; i < n; i++) {
                if (graph[init][i] == 1 && init != i) {
                    q.add(i);
                }
            }
            visited[init] = true;
            while (!q.isEmpty()) {
                int curr = q.poll();
                if (!visited[curr]) {
                    if (initials.contains(curr)) {
                        isCandidate[init] = false;
                        isCandidate[curr] = false;
                    }
                    visited[curr] = true;
                    dsu.join(init, curr);
                    for (int i = 0; i < n; i++) {
                        if (graph[curr][i] == 1 && curr != i) {
                            q.add(i);
                        }
                    }
                }
            }
        }
        int toBeDeleted = initial[0];
        int size = dsu.sizeMap.getOrDefault(dsu.find(initial[0]), 0);
        System.out.println(Arrays.toString(isCandidate));
        for (int i : initial) {
            int currSize = dsu.sizeMap.getOrDefault(dsu.find(i), 0);
            if ((currSize > size || !isCandidate[toBeDeleted]) && isCandidate[i]) {
                toBeDeleted = i;
                size = currSize;
            }
        }
        return toBeDeleted;
    }

    public class DSU {
        HashMap<Integer, Integer> parentMap = new HashMap<>();
        HashMap<Integer, Integer> sizeMap = new HashMap<>();

        public DSU() {}

        public Integer find(int i) {
            if (!parentMap.containsKey(i)) return null;
            return i == parentMap.get(i) ? i : find(parentMap.get(i));
        }

        public void join(int x, int y) {
            Integer parentX = find(x);
            Integer parentY = find(y);
            if (parentX == null && parentY == null) {
                parentMap.put(x, x);
                parentMap.put(y, x);
                sizeMap.put(x, 2);
            } else if (parentX == null) {
                parentMap.put(x, parentY);
                sizeMap.merge(parentY, 1, (a, b) -> a + 1);
            } else if (parentY == null) {
                parentMap.put(y, parentX);
                sizeMap.merge(parentX, 1, (a, b) -> a + 1);
            } else {
                parentMap.put(parentY, parentX);
                sizeMap.merge(parentX, 1, (a, b) -> a + sizeMap.get(parentY));
            }
        }
    }
}